// web/index.js
import express from 'express';
import cors from 'cors';
import { prisma } from './lib/prisma.js';

import pino from 'pino';
import pinoHttp from 'pino-http';
import { v4 as uuid } from 'uuid';
import { upsertAbandonedCart } from './db.js';

const app = express();

const logger = pino({
  level: process.env.LOG_LEVEL || 'info',
  transport: process.env.NODE_ENV === 'production' ? undefined : { target: 'pino-pretty' }
});

// attach request-id + structured logs
app.use((req, res, next) => {
  req.id = req.headers['x-request-id'] || uuid();
  res.setHeader('x-request-id', req.id);
  next();
});
app.use(pinoHttp({ logger, genReqId: (req) => req.id }));

app.use(express.json());
app.use(cors({ origin: '*', methods: ['GET', 'POST'], allowedHeaders: ['Content-Type','X-Api-Key','X-Shop-Domain'] }));

// Health
app.get('/health', (_req, res) => res.json({ status: 'ok', time: new Date().toISOString() }));

// --- API-key auth middleware (MerchantConfig.settings.apiKey) ---
async function apiKeyAuth(req, res, next) {
  try {
    const apiKey = req.get('X-Api-Key');
    const shopDomain = req.get('X-Shop-Domain') || req.body?.shopDomain;

    if (!apiKey || !shopDomain) {
      return res.status(401).json({ ok: false, error: 'Missing X-Api-Key or X-Shop-Domain' });
    }

    const m = await prisma.merchantConfig.findUnique({ where: { shopDomain } });
    const cfgKey = m?.settings?.apiKey; // stored in JSON "settings"
    if (!m || !cfgKey || cfgKey !== apiKey) {
      return res.status(403).json({ ok: false, error: 'Invalid API key or merchant' });
    }

    // attach merchant to request for downstream use
    req.merchant = m;
    next();
  } catch (e) {
    console.error(e);
    res.status(500).json({ ok: false, error: 'Auth error' });
  }
}

// --- Universal cart ingest (works for ANY storefront) ---
app.post('/ingest/cart', apiKeyAuth, async (req, res) => {
  try {
    const payload = req.body || {};
    const cart = await upsertAbandonedCart({
      cartId: payload.cartId,
      shopDomain: payload.shopDomain,
      customerEmail: payload.customerEmail,
      items: payload.items,
      total: payload.total,
      channel: payload.channel,
      consents: payload.consents,
      metadata: payload.metadata,
    });
    res.json({ ok: true, cartId: cart.cartId, id: cart.id });
  } catch (e) {
    console.error(e);
    res.status(400).json({ ok: false, error: e.message });
  }
});

// (keep any Shopify routes you already have… they can coexist)

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`API listening on http://localhost:${PORT}`);
});


/* --- Copy generation route --- */
app.post('/copy/generate', express.json(), async (req, res) => {
  try {
    const { cartId, variant = 'subject_a' } = req.body;
    const shop = req.get('X-Shop-Domain');
    const key  = req.get('X-Api-Key');

    // Verify merchant + API key
    const mc = await prisma.merchantConfig.findUnique({ where: { shopDomain: shop } });
    if (!mc || mc.settings?.apiKey !== key) {
      return res.status(401).json({ ok: false, error: 'Invalid API key or merchant' });
    }

    // Load cart + items
    const cart = await prisma.abandonedCart.findUnique({
      where: { cartId },
      include: { items: true },
    });
    if (!cart) return res.status(404).json({ ok: false, error: 'Cart not found' });

    // Simple copy (no external API; safe + deterministic)
    const itemList =
      (cart.items?.map(i => `${i.quantity}× ${i.title}`).join(', ')) || 'your items';
    const subject = `You left ${itemList} in your cart`;
    const totalStr = (cart.total != null) ? `$${cart.total}` : 'your order';
    const body = [
      `Hey ${cart.customerEmail || 'there'},`,
      ``,
      `Looks like you left ${itemList} in your cart.`,
      `Complete your order for ${totalStr}.`,
      ``,
      `— ${cart.shopDomain}`
    ].join('\n');

    // Store and return
    const rec = await prisma.generatedCopy.create({
      data: {
        cartId: cart.id,
        variant,
        prompt: { variant, template: 'baseline_v1' },
        output: body,
        meta: { subject },
      },
    });

    return res.json({ ok: true, id: rec.id, subject: rec.meta.subject, body: rec.output });
  } catch (e) {
    console.error(e);
    res.status(500).json({ ok: false, error: 'copy_generate_failed' });
  }
});

/* --- List generated copy for a cartId --- */
app.get('/copy', async (req, res) => {
  try {
    const cartId = req.query.cartId;
    if (!cartId) return res.status(400).json({ ok: false, error: 'cartId required' });

    const cart = await prisma.abandonedCart.findUnique({ where: { cartId } });
    if (!cart) return res.json([]);

    const rows = await prisma.generatedCopy.findMany({
      where: { cartId: cart.id },
      orderBy: { createdAt: 'desc' },
    });
    res.json(rows);
  } catch (e) {
    console.error(e);
    res.status(500).json({ ok: false });
  }
});

